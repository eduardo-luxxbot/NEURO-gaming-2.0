<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECOS DO ABISMO - Possess√£o Procedural</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Space+Mono:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --void: #0a0a0f;
            --flesh: #8b2635;
            --flesh-light: #c93a4f;
            --neural: #4a90e2;
            --toxic: #39ff14;
            --bone: #e8dcc4;
            --shadow: #1a1a2e;
            --gold: #ffd700;
            --corruption: #9400d3;
        }

        body {
            background: var(--void);
            color: var(--bone);
            font-family: 'Space Mono', monospace;
            overflow: hidden;
            position: relative;
        }

        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .hud-panel {
            position: absolute;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid var(--flesh);
            padding: 15px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        #possession-bar {
            top: 20px;
            left: 20px;
            min-width: 300px;
            border-left: 4px solid var(--toxic);
        }

        #possession-bar h2 {
            font-family: 'Cinzel', serif;
            color: var(--toxic);
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .body-slot {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.2s;
        }

        .body-slot:hover {
            background: rgba(57, 255, 20, 0.1);
            border-color: var(--toxic);
        }

        .body-slot.active {
            background: rgba(57, 255, 20, 0.2);
            border-color: var(--toxic);
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.3);
        }

        .body-icon {
            width: 40px;
            height: 40px;
            background: var(--shadow);
            border: 2px solid var(--flesh);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .body-info {
            flex: 1;
        }

        .body-name {
            font-weight: bold;
            color: var(--bone);
            font-size: 12px;
        }

        .body-condition {
            font-size: 10px;
            color: var(--flesh-light);
            margin-top: 2px;
        }

        .health-bar {
            width: 100%;
            height: 4px;
            background: var(--shadow);
            margin-top: 5px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--flesh), var(--flesh-light));
            transition: width 0.3s;
        }

        #world-status {
            top: 20px;
            right: 20px;
            text-align: right;
            border-right: 4px solid var(--corruption);
        }

        .decay-timer {
            font-size: 24px;
            font-weight: bold;
            color: var(--corruption);
            font-family: 'Cinzel', serif;
            text-shadow: 0 0 20px var(--corruption);
        }

        .biome-indicator {
            margin-top: 10px;
            font-size: 11px;
            color: var(--neural);
        }

        #echo-mode {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(148, 0, 211, 0.2);
            border: 2px solid var(--corruption);
            padding: 40px;
            text-align: center;
            display: none;
            pointer-events: auto;
            backdrop-filter: blur(20px);
            z-index: 200;
        }

        #echo-mode.active {
            display: block;
            animation: echoPulse 2s infinite;
        }

        @keyframes echoPulse {
            0%, 100% { box-shadow: 0 0 50px var(--corruption); }
            50% { box-shadow: 0 0 100px var(--corruption), inset 0 0 50px rgba(148, 0, 211, 0.3); }
        }

        #echo-mode h1 {
            font-family: 'Cinzel', serif;
            font-size: 32px;
            color: var(--corruption);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        .corpse-target {
            display: inline-block;
            margin: 10px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--flesh);
            cursor: pointer;
            transition: all 0.3s;
            min-width: 150px;
        }

        .corpse-target:hover {
            transform: scale(1.1);
            border-color: var(--toxic);
            box-shadow: 0 0 30px var(--toxic);
        }

        #dialogue-box {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            background: rgba(10, 10, 15, 0.98);
            border: 2px solid var(--gold);
            padding: 30px;
            display: none;
            pointer-events: auto;
        }

        #dialogue-box.active {
            display: block;
            animation: dialogueSlide 0.5s ease;
        }

        @keyframes dialogueSlide {
            from { transform: translateX(-50%) translateY(100px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        .npc-name {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 18px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .npc-mood {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--toxic);
        }

        .npc-text {
            font-size: 14px;
            line-height: 1.8;
            color: var(--bone);
            margin-bottom: 20px;
        }

        .dialogue-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .dialogue-btn {
            background: transparent;
            border: 1px solid var(--flesh);
            color: var(--bone);
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-size: 12px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .dialogue-btn:hover {
            background: var(--flesh);
            color: var(--void);
            transform: translateX(5px);
        }

        .dialogue-btn::before {
            content: '>';
            position: absolute;
            left: -20px;
            transition: left 0.3s;
        }

        .dialogue-btn:hover::before {
            left: 5px;
        }

        #memory-map {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 200px;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid var(--neural);
            pointer-events: auto;
            cursor: crosshair;
        }

        #memory-map canvas {
            width: 100%;
            height: 100%;
        }

        .map-hint {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 9px;
            color: var(--neural);
            opacity: 0.7;
        }

        #corruption-meter {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 30px;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--corruption);
            display: flex;
            flex-direction: column-reverse;
        }

        .corruption-fill {
            background: linear-gradient(to top, var(--corruption), var(--flesh));
            transition: height 0.5s;
            position: relative;
        }

        .corruption-label {
            position: absolute;
            right: 40px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
            font-size: 10px;
            color: var(--corruption);
            white-space: nowrap;
            letter-spacing: 2px;
        }

        .notification {
            position: fixed;
            top: 100px;
            right: -400px;
            background: rgba(10, 10, 15, 0.98);
            border-left: 4px solid var(--toxic);
            padding: 20px;
            max-width: 350px;
            transition: right 0.5s ease;
            pointer-events: auto;
            z-index: 150;
        }

        .notification.show {
            right: 20px;
        }

        .notification-title {
            font-family: 'Cinzel', serif;
            color: var(--toxic);
            font-size: 14px;
            margin-bottom: 8px;
        }

        .notification-text {
            font-size: 11px;
            color: var(--bone);
            line-height: 1.6;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--void);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            font-family: 'Cinzel', serif;
            font-size: 48px;
            color: var(--flesh);
            animation: loadingPulse 2s infinite;
            margin-bottom: 30px;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 0.3; text-shadow: 0 0 20px var(--flesh); }
            50% { opacity: 1; text-shadow: 0 0 50px var(--flesh), 0 0 100px var(--flesh); }
        }

        .loading-bar {
            width: 400px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .loading-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--flesh), var(--toxic));
            animation: loading 3s ease forwards;
        }

        @keyframes loading {
            to { width: 100%; }
        }

        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.3);
            line-height: 1.8;
        }

        .controls-hint span {
            color: var(--toxic);
            margin-right: 10px;
        }

        #possession-vfx {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s;
            background: radial-gradient(circle at center, transparent 0%, var(--corruption) 50%, transparent 100%);
            mix-blend-mode: screen;
        }

        #possession-vfx.active {
            opacity: 0.3;
            animation: possessionRipple 1s ease;
        }

        @keyframes possessionRipple {
            0% { transform: scale(0); opacity: 0; }
            50% { opacity: 0.5; }
            100% { transform: scale(3); opacity: 0; }
        }

        .trait-badge {
            display: inline-block;
            padding: 2px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 9px;
            margin: 2px;
            border-radius: 3px;
        }

        .trait-paranoid { border-color: var(--flesh); color: var(--flesh-light); }
        .trait-generous { border-color: var(--toxic); color: var(--toxic); }
        .trait-trauma { border-color: var(--corruption); color: var(--corruption); }

        #death-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
            pointer-events: auto;
        }

        #death-screen.active {
            display: flex;
        }

        .death-title {
            font-family: 'Cinzel', serif;
            font-size: 64px;
            color: var(--flesh);
            margin-bottom: 20px;
            animation: deathShake 0.5s infinite;
        }

        @keyframes deathShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .death-subtitle {
            font-size: 16px;
            color: var(--bone);
            margin-bottom: 40px;
            opacity: 0.7;
        }

        .echo-option {
            background: rgba(148, 0, 211, 0.2);
            border: 1px solid var(--corruption);
            padding: 20px 40px;
            margin: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .echo-option:hover {
            background: rgba(148, 0, 211, 0.4);
            transform: scale(1.05);
            box-shadow: 0 0 40px var(--corruption);
        }

        .echo-option h3 {
            color: var(--corruption);
            font-family: 'Cinzel', serif;
            margin-bottom: 10px;
        }

        .echo-option p {
            font-size: 11px;
            color: var(--bone);
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="loading-text">ECOS DO ABISMO</div>
        <div class="loading-bar">
            <div class="loading-progress"></div>
        </div>
        <div style="margin-top: 20px; font-size: 12px; color: var(--flesh-light);">
            Gerando DNA de 200+ NPCs... Criando biomas org√¢nicos...
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="possession-vfx"></div>

    <div id="ui-layer">
        <div id="possession-bar" class="hud-panel">
            <h2>‚óà Corpos Possu√≠dos</h2>
            <div id="body-list"></div>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="font-size: 10px; color: var(--toxic); margin-bottom: 5px;">CAMINHO ATUAL</div>
                <div id="current-path" style="font-size: 12px; font-weight: bold;">Eco Errante</div>
                <div id="path-progress" style="font-size: 10px; color: var(--bone); margin-top: 5px;">0/100 corpos consumidos</div>
            </div>
        </div>

        <div id="world-status" class="hud-panel">
            <div style="font-size: 10px; color: var(--corruption); margin-bottom: 5px;">DECAD√äNCIA DO DEUS</div>
            <div class="decay-timer" id="decay-timer">71:59:59</div>
            <div class="biome-indicator" id="biome-indicator">
                ‚óà Bioma: Cord√£o Umbilical<br>
                ‚óà Temperatura: 37¬∞C<br>
                ‚óà Toxicidade: Baixa
            </div>
            <div style="margin-top: 15px; font-size: 10px; color: var(--gold);">
                ‚óà Sementes: <span id="seeds-count">0</span><br>
                ‚óà Mem√≥rias Vendidas: <span id="memories-count">0</span>
            </div>
        </div>

        <div id="corruption-meter">
            <div class="corruption-label">CORRUP√á√ÉO</div>
            <div class="corruption-fill" id="corruption-fill" style="height: 5%;"></div>
        </div>

        <div id="memory-map">
            <canvas id="mapCanvas"></canvas>
            <div class="map-hint">Clique para anotar ‚Ä¢ Scroll para zoom</div>
        </div>

        <div class="controls-hint">
            <span>[WASD]</span> Mover<br>
            <span>[E]</span> Interagir<br>
            <span>[ESPA√áO]</span> Modo Eco (possess√£o)<br>
            <span>[Q]</span> Trocar corpo<br>
            <span>[M]</span> Mapa de mem√≥ria<br>
            <span>[TAB]</span> Invent√°rio
        </div>
    </div>

    <div id="echo-mode">
        <h1>‚óà MODO ECO ‚óà</h1>
        <p style="margin-bottom: 30px; opacity: 0.8;">Voc√™ est√° fora do corpo. Escolha um cad√°ver para possuir:</p>
        <div id="corpse-list"></div>
        <p style="margin-top: 30px; font-size: 11px; color: var(--corruption);">
            Cada possess√£o consome 5% de sanidade m√°xima permanente
        </p>
    </div>

    <div id="dialogue-box">
        <div class="npc-name">
            <div class="npc-mood" id="npc-mood"></div>
            <span id="npc-name">Nome do NPC</span>
            <div style="margin-left: auto; font-size: 10px; color: var(--flesh-light);" id="npc-traits"></div>
        </div>
        <div class="npc-text" id="npc-text">Texto do NPC aqui...</div>
        <div class="dialogue-options" id="dialogue-options"></div>
    </div>

    <div id="death-screen">
        <div class="death-title">‚óà CORPO DESTRU√çDO ‚óà</div>
        <div class="death-subtitle">Sua consci√™ncia flutua no vazio entre os mundos</div>
        <div style="display: flex; gap: 20px;">
            <div class="echo-option" onclick="game.respawn('near')">
                <h3>ECO PROXIMAL</h3>
                <p>Reapare√ßa perto do corpo morto<br>Custo: 1 Semente</p>
            </div>
            <div class="echo-option" onclick="game.respawn('random')">
                <h3>ECO ALEAT√ìRIO</h3>
                <p>Reapare√ßa em bioma aleat√≥rio<br>Custo: 30% das mem√≥rias</p>
            </div>
            <div class="echo-option" onclick="game.respawn('possess')">
                <h3>POSSESS√ÉO FOR√áADA</h3>
                <p>Controle o inimigo que te matou<br>Custo: 50% de sanidade m√°xima</p>
            </div>
        </div>
    </div>

    <script>
        // SISTEMA DE DNA PROCEDURAL PARA NPCs
        class DNA {
            constructor(seed = Math.random()) {
                this.seed = seed;
                this.rng = new RNG(seed);
                this.generate();
            }

            generate() {
                // Tra√ßos de personalidade (0-100)
                this.traits = {
                    paranoia: this.rng.next(0, 100),
                    altruism: this.rng.next(0, 100),
                    aggression: this.rng.next(0, 100),
                    curiosity: this.rng.next(0, 100),
                    loyalty: this.rng.next(0, 100),
                    trauma: this.rng.next(0, 100)
                };

                // Profiss√£o baseada em tra√ßos
                this.profession = this.selectProfession();
                
                // Nome procedural
                this.name = this.generateName();
                
                // Hist√≥ria de vida
                this.lifeStory = this.generateLifeStory();
                
                // Mem√≥rias do jogador (o que este NPC lembra das intera√ß√µes)
                this.playerMemories = [];
                
                // Ciclo de vida
                this.age = this.rng.next(18, 70);
                this.maxAge = this.age + this.rng.next(5, 30);
                this.isAlive = true;

                // Apar√™ncia √∫nica (silhueta)
                this.silhouette = this.generateSilhouette();
            }

            selectProfession() {
                const professions = [
                    { name: 'Necromante de L√°grimas', req: t => t.trauma > 60 && t.curiosity > 50 },
                    { name: 'Ferreira de Ossos', req: t => t.aggression > 60 && t.paranoia < 40 },
                    { name: 'Mercador de Mem√≥rias', req: t => t.altruism < 30 && t.curiosity > 70 },
                    { name: 'Herege do Sangue', req: t => t.trauma > 70 && t.loyalty < 30 },
                    { name: 'Jardineiro de Fungos', req: t => t.altruism > 60 && t.aggression < 40 },
                    { name: 'Ca√ßador de Ecos', req: t => t.aggression > 70 && t.paranoia > 50 },
                    { name: 'Sacerdote Podre', req: t => t.loyalty > 70 && t.trauma > 40 },
                    { name: 'Alquimista de Carne', req: t => t.curiosity > 80 && t.altruism < 50 },
                    { name: 'Pescador de Almas', req: t => t.trauma > 50 && t.aggression < 50 },
                    { name: 'Escriba de Cicatrizes', req: t => t.curiosity > 60 && t.paranoia > 40 }
                ];

                const valid = professions.filter(p => p.req(this.traits));
                return valid.length > 0 
                    ? valid[this.rng.next(0, valid.length - 1)].name 
                    : professions[0].name;
            }

            generateName() {
                const prefixes = ['Kael', 'Mira', 'Zeth', 'Lys', 'Vorn', 'Iris', 'Obl', 'Xan', 'Yul', 'Kor'];
                const suffixes = ['-7', ' o Manchado', ' Vazio', ' de Cinzas', '-Null', ' ++', ' Œ©', ' √ê', ' the Hollow', ' Prime'];
                const prefix = prefixes[this.rng.next(0, prefixes.length - 1)];
                const suffix = this.rng.next(0, 100) > 70 ? suffixes[this.rng.next(0, suffixes.length - 1)] : '';
                return prefix + suffix;
            }

            generateLifeStory() {
                const events = [
                    'testemunhou a queda do deus',
                    'perdeu a fam√≠lia para a podrid√£o',
                    'foi tra√≠do por um eco',
                    'descobriu uma verdade proibida',
                    'foi ressuscitado 3 vezes',
                    'vendeu suas mem√≥rias de inf√¢ncia',
                    'possuiu um deus menor',
                    'sobreviveu ao colapso do f√≠gado'
                ];
                
                const event = events[this.rng.next(0, events.length - 1)];
                return `Um ${this.profession.toLowerCase()} que ${event}.`;
            }

            generateSilhouette() {
                // Gera par√¢metros √∫nicos para desenhar a silhueta
                return {
                    height: this.rng.next(0.8, 1.4),
                    width: this.rng.next(0.6, 1.2),
                    hunch: this.rng.next(-0.3, 0.3),
                    limbs: this.rng.next(0.7, 1.3),
                    corruption: this.rng.next(0, this.traits.trauma / 100)
                };
            }

            interact(player, context) {
                // L√≥gica de di√°logo baseada em mem√≥rias e tra√ßos
                let disposition = 50;
                
                // Modificadores baseados em mem√≥rias
                this.playerMemories.forEach(mem => {
                    if (mem.type === 'betrayal') disposition -= 40;
                    if (mem.type === 'help') disposition += 30;
                    if (mem.type === 'trade_fair') disposition += 20;
                    if (mem.type === 'possessed_friend') disposition -= 60;
                });

                // Modificadores de tra√ßos
                if (this.traits.paranoia > 70) disposition -= 20;
                if (this.traits.altruism > 70) disposition += 15;

                // Verifica se reconhece o jogador em corpo diferente
                const recognized = this.playerMemories.length > 0 && 
                    this.playerMemories.some(m => m.playerId === player.id);

                return {
                    disposition: Math.max(0, Math.min(100, disposition)),
                    recognized,
                    dialogue: this.generateDialogue(disposition, recognized, context),
                    options: this.generateOptions(disposition, context)
                };
            }

            generateDialogue(disposition, recognized, context) {
                if (recognized && disposition < 30) {
                    return `Eu te reconhe√ßo, eco. N√£o importa que carne voc√™ veste agora. Voc√™ me traiu antes, e eu n√£o esque√ßo.`;
                }
                if (recognized && disposition > 70) {
                    return `Ah, √© voc√™! Mesmo nesse novo vaso de carne, eu reconhe√ßo sua... ess√™ncia. O que precisa, amigo?`;
                }
                if (this.traits.paranoia > 80) {
                    return `N√£o chegue perto. Eu sei o que voc√™ √©. Eu sei o que TODOS s√£o. Os ecos est√£o em toda parte.`;
                }
                if (context === 'first_meeting') {
                    return `Um novo eco flutuando pelo corpo do deus? Cuidado, carne estrangeira. Nem todos aqui apreciam... turistas.`;
                }
                return `Sou ${this.name}, ${this.profession.toLowerCase()}. O que voc√™ busca nas entranhas do cad√°ver divino?`;
            }

            generateOptions(disposition, context) {
                const options = [];
                if (disposition > 40) {
                    options.push({ text: 'Com√©rcio', action: 'trade' });
                    options.push({ text: 'Informa√ß√µes', action: 'info' });
                }
                if (disposition > 70) {
                    options.push({ text: 'Seguir-me (Companion)', action: 'follow' });
                }
                if (this.profession.includes('Necromante') || this.profession.includes('Alquimista')) {
                    options.push({ text: 'Ressurrei√ß√£o', action: 'resurrect' });
                }
                options.push({ text: 'Amea√ßar', action: 'threaten' });
                options.push({ text: 'Sair', action: 'leave' });
                return options;
            }

            addMemory(type, playerId, details) {
                this.playerMemories.push({ type, playerId, details, timestamp: Date.now() });
                // NPCs esquecem mem√≥rias antigas baseado em trauma (mais trauma = mais obsessivo = n√£o esquece)
                const memoryLimit = 5 + Math.floor(this.traits.trauma / 20);
                if (this.playerMemories.length > memoryLimit) {
                    this.playerMemories.shift();
                }
            }

            update(deltaTime) {
                this.age += deltaTime / 3600; // envelhece em horas reais
                if (this.age >= this.maxAge && this.rng.next(0, 1000) < 1) {
                    this.isAlive = false;
                    return 'died_natural';
                }
                return 'alive';
            }
        }

        // Gerador de n√∫meros pseudo-aleat√≥rios seedable
        class RNG {
            constructor(seed) {
                this.seed = seed;
            }
            next(min = 0, max = 1) {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                const rnd = this.seed / 233280;
                return min + rnd * (max - min);
            }
        }

        // SISTEMA DE CORPOS/JOGADOR
        class Body {
            constructor(type, dna = null) {
                this.type = type;
                this.dna = dna;
                this.id = Math.random().toString(36).substr(2, 9);
                this.health = 100;
                this.maxHealth = 100;
                this.abilities = this.getAbilities();
                this.stats = this.getStats();
                this.age = 0;
                this.corruption = 0;
            }

            getAbilities() {
                const abilities = {
                    human: ['usar_itens', 'falar', 'comercio', 'correr'],
                    wolf: ['farejar', 'correr_rapido', 'morder', 'uivar'],
                    fungus: ['espores_venenosos', 'regeneracao', 'controle_micelio', 'crescer'],
                    fish: ['respirar_agua', 'nadar_rapido', 'bioluminescencia', 'eletrorecep√ß√£o'],
                    bird: ['voar', 'visao_agucada', 'canto', 'mergulho'],
                    golem_flesh: ['forca_bruta', 'resistencia', 'auto_reparo', 'absorver_dano']
                };
                return abilities[this.type] || abilities.human;
            }

            getStats() {
                const stats = {
                    human: { speed: 1, damage: 10, defense: 10, special: 5 },
                    wolf: { speed: 2.5, damage: 15, defense: 5, special: 8 },
                    fungus: { speed: 0.3, damage: 20, defense: 20, special: 10 },
                    fish: { speed: 1.5, damage: 5, defense: 3, special: 7 },
                    bird: { speed: 3, damage: 8, defense: 2, special: 6 },
                    golem_flesh: { speed: 0.5, damage: 25, defense: 30, special: 3 }
                };
                return stats[this.type] || stats.human;
            }

            takeDamage(amount) {
                this.health -= amount * (1 - this.stats.defense / 100);
                return this.health <= 0;
            }

            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
            }
        }

        // SISTEMA DE BIOMAS (√ìRG√ÉOS DO DEUS)
        class Biome {
            constructor(name, type, x, y, width, height) {
                this.name = name;
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.decayLevel = 0;
                this.entities = [];
                this.connections = [];
                this.hazards = this.generateHazards();
                this.resources = this.generateResources();
            }

            generateHazards() {
                const hazards = {
                    'heart': [{ type: 'lava_vein', damage: 20, x: 100, y: 100 }],
                    'lung': [{ type: 'acid_pool', damage: 15, x: 200, y: 300 }],
                    'brain': [{ type: 'neural_blast', damage: 25, x: 150, y: 150 }],
                    'liver': [{ type: 'toxin_cloud', damage: 10, x: 300, y: 200 }],
                    'stomach': [{ type: 'acid_wave', damage: 30, x: 400, y: 400 }]
                };
                return hazards[this.type] || [];
            }

            generateResources() {
                return Array(5).fill(null).map((_, i) => ({
                    type: ['seed', 'memory_fragment', 'flesh_chunk', 'neural_crystal'][Math.floor(Math.random() * 4)],
                    x: this.x + Math.random() * this.width,
                    y: this.y + Math.random() * this.height,
                    collected: false
                }));
            }

            update(deltaTime, globalDecay) {
                this.decayLevel += globalDecay * deltaTime;
                
                // Bioma morre se decair demais
                if (this.decayLevel > 100) {
                    return 'collapsed';
                }

                // Atualiza entidades
                this.entities = this.entities.filter(e => {
                    if (e instanceof DNA) {
                        return e.isAlive;
                    }
                    return true;
                });

                return 'active';
            }

            getVisualData() {
                return {
                    color: this.getBiomeColor(),
                    particles: this.generateParticles(),
                    silhouette: this.generateBiomeSilhouette()
                };
            }

            getBiomeColor() {
                const colors = {
                    'heart': `hsl(0, ${70 - this.decayLevel}%, ${30 + this.decayLevel/3}%)`,
                    'lung': `hsl(120, ${60 - this.decayLevel/2}%, ${25 + this.decayLevel/4}%)`,
                    'brain': `hsl(220, ${80 - this.decayLevel}%, ${40 + this.decayLevel/5}%)`,
                    'liver': `hsl(30, ${90 - this.decayLevel}%, ${20 + this.decayLevel/3}%)`,
                    'stomach': `hsl(60, ${50 - this.decayLevel/2}%, ${15 + this.decayLevel/2}%)`
                };
                return colors[this.type] || '#333';
            }

            generateParticles() {
                // Part√≠culas baseadas no estado de decomposi√ß√£o
                const count = Math.floor(this.decayLevel / 10);
                return Array(count).fill(null).map(() => ({
                    x: this.x + Math.random() * this.width,
                    y: this.y + Math.random() * this.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    life: Math.random() * 100,
                    type: this.type === 'lung' ? 'spore' : 'dust'
                }));
            }

            generateBiomeSilhouette() {
                // Gera formas org√¢nicas √∫nicas para cada bioma
                const points = [];
                const segments = 20;
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const radius = 100 + Math.sin(angle * 3) * 30 + Math.random() * 20;
                    points.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                }
                return points;
            }
        }

        // MOTOR DO JOGO PRINCIPAL
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;

                this.camera = { x: 0, y: 0, zoom: 1, rotation: 0 };
                this.player = {
                    id: 'player_' + Math.random().toString(36).substr(2, 9),
                    x: 0,
                    y: 0,
                    currentBody: null,
                    bodies: [],
                    echoMode: false,
                    sanity: 100,
                    maxSanity: 100,
                    seeds: 0,
                    memoriesSold: 0,
                    corruption: 5,
                    path: 'Eco Errante',
                    pathProgress: 0,
                    mapAnnotations: []
                };

                this.npcs = [];
                this.biomes = [];
                this.corpses = [];
                this.particles = [];
                this.globalDecay = 0.001; // 72 horas para decomposi√ß√£o total
                this.startTime = Date.now();
                this.lastTime = Date.now();

                this.keys = {};
                this.mouse = { x: 0, y: 0, clicked: false };

                this.init();
            }

            async init() {
                this.generateWorld();
                this.setupEventListeners();
                this.startGameLoop();
                
                // Remove tela de loading
                setTimeout(() => {
                    document.getElementById('loading-screen').classList.add('hidden');
                    this.showNotification('Bem-vindo ao Cad√°ver', 'Voc√™ acordou nas entranhas de um deus morto. Encontre um corpo antes que seu eco se dissipe.');
                }, 3500);
            }

            generateWorld() {
                // Gera biomas (√≥rg√£os do deus)
                const organLayout = [
                    { name: 'Cora√ß√£o Ardente', type: 'heart', x: 0, y: 0, w: 800, h: 600 },
                    { name: 'Pulm√£o do P√¢ntano', type: 'lung', x: -1000, y: -500, w: 900, h: 700 },
                    { name: 'Corteza Neural', type: 'brain', x: 1000, y: -800, w: 1000, h: 800 },
                    { name: 'F√≠gado T√≥xico', type: 'liver', x: -800, y: 800, w: 700, h: 600 },
                    { name: 'Est√¥mago √Åcido', type: 'stomach', x: 1200, y: 600, w: 800, h: 700 }
                ];

                organLayout.forEach(organ => {
                    this.biomes.push(new Biome(organ.name, organ.type, organ.x, organ.y, organ.w, organ.h));
                });

                // Gera 200+ NPCs com DNA √∫nico
                for (let i = 0; i < 200; i++) {
                    const biome = this.biomes[Math.floor(Math.random() * this.biomes.length)];
                    const dna = new DNA(Math.random());
                    const npc = {
                        dna: dna,
                        x: biome.x + Math.random() * biome.width,
                        y: biome.y + Math.random() * biome.height,
                        biome: biome,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        state: 'idle',
                        target: null
                    };
                    this.npcs.push(npc);
                    biome.entities.push(dna);
                }

                // Corpo inicial do jogador (cad√°ver aleat√≥rio)
                const startBiome = this.biomes[0];
                this.player.x = startBiome.x + startBiome.width / 2;
                this.player.y = startBiome.y + startBiome.height / 2;
                
                const initialBody = new Body('human');
                this.player.currentBody = initialBody;
                this.player.bodies.push(initialBody);

                // Gera alguns cad√°veres iniciais
                for (let i = 0; i < 10; i++) {
                    this.spawnCorpse();
                }
            }

            spawnCorpse() {
                const biome = this.biomes[Math.floor(Math.random() * this.biomes.length)];
                const types = ['human', 'wolf', 'fungus', 'fish', 'bird', 'golem_flesh'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                this.corpses.push({
                    type: type,
                    x: biome.x + Math.random() * biome.width,
                    y: biome.y + Math.random() * biome.height,
                    biome: biome,
                    decay: 0,
                    body: new Body(type)
                });
            }

            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    this.handleInput(e.key.toLowerCase());
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });

                window.addEventListener('click', (e) => {
                    this.mouse.clicked = true;
                    setTimeout(() => this.mouse.clicked = false, 100);
                });

                window.addEventListener('resize', () => {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.canvas.width = this.width;
                    this.canvas.height = this.height;
                });

                // Mapa de mem√≥ria
                const mapCanvas = document.getElementById('mapCanvas');
                mapCanvas.width = 300;
                mapCanvas.height = 200;
                
                mapCanvas.addEventListener('click', (e) => {
                    const rect = mapCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.addMapAnnotation(x, y);
                });
            }

            handleInput(key) {
                if (key === ' ') {
                    this.toggleEchoMode();
                } else if (key === 'q') {
                    this.cycleBody();
                } else if (key === 'e') {
                    this.interact();
                } else if (key === 'm') {
                    this.toggleMap();
                }
            }

            toggleEchoMode() {
                if (this.player.echoMode) {
                    this.player.echoMode = false;
                    document.getElementById('echo-mode').classList.remove('active');
                } else {
                    this.player.echoMode = true;
                    this.updateEchoUI();
                    document.getElementById('echo-mode').classList.add('active');
                    document.getElementById('possession-vfx').classList.add('active');
                    setTimeout(() => {
                        document.getElementById('possession-vfx').classList.remove('active');
                    }, 1000);
                }
            }

            updateEchoUI() {
                const corpseList = document.getElementById('corpse-list');
                corpseList.innerHTML = '';
                
                // Mostra cad√°veres pr√≥ximos
                const nearby = this.corpses.filter(c => {
                    const dist = Math.hypot(c.x - this.player.x, c.y - this.player.y);
                    return dist < 300 && c.decay < 80;
                });

                if (nearby.length === 0) {
                    corpseList.innerHTML = '<p style="color: var(--flesh);">Nenhum cad√°ver vi√°vel pr√≥ximo...</p>';
                    return;
                }

                nearby.forEach(corpse => {
                    const div = document.createElement('div');
                    div.className = 'corpse-target';
                    div.innerHTML = `
                        <div style="font-size: 24px; margin-bottom: 10px;">${this.getBodyEmoji(corpse.type)}</div>
                        <div style="font-weight: bold; color: var(--toxic);">${corpse.type.toUpperCase()}</div>
                        <div style="font-size: 10px; color: var(--bone); margin-top: 5px;">
                            Decomposi√ß√£o: ${Math.floor(corpse.decay)}%<br>
                            Habilidades: ${corpse.body.abilities.slice(0, 2).join(', ')}
                        </div>
                    `;
                    div.onclick = () => this.possess(corpse);
                    corpseList.appendChild(div);
                });
            }

            getBodyEmoji(type) {
                const emojis = {
                    human: 'üë§',
                    wolf: 'üê∫',
                    fungus: 'üçÑ',
                    fish: 'üêü',
                    bird: 'ü¶Ö',
                    golem_flesh: 'üßü'
                };
                return emojis[type] || 'üë§';
            }

            possess(corpse) {
                // Custa sanidade m√°xima permanente
                this.player.maxSanity -= 5;
                this.player.sanity = Math.min(this.player.sanity, this.player.maxSanity);
                
                // Adiciona corpo ao invent√°rio
                this.player.bodies.push(corpse.body);
                this.player.currentBody = corpse.body;
                
                // Remove cad√°ver do mundo
                this.corpses = this.corpses.filter(c => c !== corpse);
                
                // Atualiza progresso de caminho
                this.player.pathProgress++;
                this.updatePath();
                
                this.toggleEchoMode();
                this.showNotification('Possess√£o Completa', `Voc√™ agora habita um ${corpse.type}. Sanidade m√°xima reduzida para ${this.player.maxSanity}.`);
                this.updateUI();
            }

            updatePath() {
                const progress = this.player.pathProgress;
                if (progress > 100) this.player.path = 'Necromante de Carne';
                else if (progress > 50) this.player.path = 'Colecionador de Vessels';
                else if (progress > 20) this.player.path = 'Eco Faminto';
                
                // Verifica caminhos especiais
                const fungusTime = this.player.bodies.filter(b => b.type === 'fungus').length;
                if (fungusTime > 10) this.player.path = 'Sinfonia F√∫ngica';
                
                const kills = this.player.bodies.filter(b => b.type === 'human').length;
                if (kills > 30) this.player.path = 'Carn√≠voro de Consci√™ncias';
            }

            cycleBody() {
                if (this.player.bodies.length < 2) return;
                
                const currentIndex = this.player.bodies.indexOf(this.player.currentBody);
                const nextIndex = (currentIndex + 1) % this.player.bodies.length;
                this.player.currentBody = this.player.bodies[nextIndex];
                
                this.showNotification('Troca de Corpo', `Agora controlando: ${this.player.currentBody.type}`);
                this.updateUI();
            }

            interact() {
                // Verifica NPCs pr√≥ximos
                const nearby = this.npcs.filter(n => {
                    const dist = Math.hypot(n.x - this.player.x, n.y - this.player.y);
                    return dist < 100;
                });

                if (nearby.length > 0) {
                    this.startDialogue(nearby[0]);
                }
            }

            startDialogue(npc) {
                const interaction = npc.dna.interact(this.player, 'first_meeting');
                const box = document.getElementById('dialogue-box');
                
                document.getElementById('npc-name').textContent = npc.dna.name;
                document.getElementById('npc-mood').style.background = 
                    interaction.disposition > 70 ? '#22c55e' : 
                    interaction.disposition > 40 ? '#eab308' : '#ef4444';
                
                // Mostra tra√ßos
                const traitsDiv = document.getElementById('npc-traits');
                traitsDiv.innerHTML = '';
                Object.entries(npc.dna.traits).forEach(([trait, value]) => {
                    if (value > 70) {
                        const badge = document.createElement('span');
                        badge.className = `trait-badge trait-${trait}`;
                        badge.textContent = `${trait}: ${value}`;
                        traitsDiv.appendChild(badge);
                    }
                });

                document.getElementById('npc-text').textContent = interaction.dialogue;
                
                const optionsDiv = document.getElementById('dialogue-options');
                optionsDiv.innerHTML = '';
                interaction.options.forEach(opt => {
                    const btn = document.createElement('button');
                    btn.className = 'dialogue-btn';
                    btn.textContent = opt.text;
                    btn.onclick = () => this.handleDialogueOption(opt, npc);
                    optionsDiv.appendChild(btn);
                });

                box.classList.add('active');
            }

            handleDialogueOption(option, npc) {
                if (option.action === 'leave') {
                    document.getElementById('dialogue-box').classList.remove('active');
                } else if (option.action === 'trade') {
                    this.showNotification('Com√©rcio', 'Sistema de troca em desenvolvimento...');
                } else if (option.action === 'threaten') {
                    npc.dna.addMemory('betrayal', this.player.id, 'Amea√ßado durante di√°logo');
                    this.showNotification('Amea√ßa', `${npc.dna.name} agora teme voc√™.`);
                    document.getElementById('dialogue-box').classList.remove('active');
                }
            }

            addMapAnnotation(x, y) {
                this.player.mapAnnotations.push({ x, y, text: prompt('Anota√ß√£o:') || '?' });
                this.showNotification('Mapa', 'Anota√ß√£o adicionada ao mapa de mem√≥ria.');
            }

            updateUI() {
                // Barra de corpos
                const bodyList = document.getElementById('body-list');
                bodyList.innerHTML = '';
                this.player.bodies.forEach((body, index) => {
                    const div = document.createElement('div');
                    div.className = `body-slot ${body === this.player.currentBody ? 'active' : ''}`;
                    div.innerHTML = `
                        <div class="body-icon">${this.getBodyEmoji(body.type)}</div>
                        <div class="body-info">
                            <div class="body-name">${body.type.toUpperCase()} #${index + 1}</div>
                            <div class="body-condition">Sa√∫de: ${Math.floor(body.health)}% | Corrup√ß√£o: ${Math.floor(body.corruption)}%</div>
                            <div class="health-bar">
                                <div class="health-fill" style="width: ${body.health}%"></div>
                            </div>
                        </div>
                    `;
                    bodyList.appendChild(div);
                });

                // Status do mundo
                document.getElementById('seeds-count').textContent = this.player.seeds;
                document.getElementById('memories-count').textContent = this.player.memoriesSold;
                document.getElementById('current-path').textContent = this.player.path;
                document.getElementById('path-progress').textContent = 
                    `${this.player.pathProgress} corpos consumidos`;

                // Corrup√ß√£o
                document.getElementById('corruption-fill').style.height = `${this.player.corruption}%`;

                // Timer de decad√™ncia
                const elapsed = (Date.now() - this.startTime) / 1000;
                const remaining = Math.max(0, 72 * 3600 - elapsed);
                const hours = Math.floor(remaining / 3600);
                const minutes = Math.floor((remaining % 3600) / 60);
                const seconds = Math.floor(remaining % 60);
                document.getElementById('decay-timer').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            showNotification(title, text) {
                const notif = document.createElement('div');
                notif.className = 'notification';
                notif.innerHTML = `
                    <div class="notification-title">${title}</div>
                    <div class="notification-text">${text}</div>
                `;
                document.body.appendChild(notif);
                
                setTimeout(() => notif.classList.add('show'), 100);
                setTimeout(() => {
                    notif.classList.remove('show');
                    setTimeout(() => notif.remove(), 500);
                }, 5000);
            }

            update(deltaTime) {
                // Atualiza biomas (decad√™ncia)
                this.biomes.forEach(biome => {
                    const status = biome.update(deltaTime, this.globalDecay);
                    if (status === 'collapsed') {
                        this.showNotification('Colapso', `${biome.name} apodreceu completamente!`);
                    }
                });

                // Atualiza NPCs
                this.npcs.forEach(npc => {
                    // Movimento simples
                    if (Math.random() < 0.02) {
                        npc.vx = (Math.random() - 0.5) * 0.5;
                        npc.vy = (Math.random() - 0.5) * 0.5;
                    }
                    
                    npc.x += npc.vx * deltaTime * 0.1;
                    npc.y += npc.vy * deltaTime * 0.1;

                    // Mant√©m dentro do bioma
                    if (npc.x < npc.biome.x) npc.x = npc.biome.x;
                    if (npc.x > npc.biome.x + npc.biome.width) npc.x = npc.biome.x + npc.biome.width;
                    if (npc.y < npc.biome.y) npc.y = npc.biome.y;
                    if (npc.y > npc.biome.y + npc.biome.height) npc.y = npc.biome.y + npc.biome.height;

                    // Atualiza DNA
                    npc.dna.update(deltaTime);
                });

                // Atualiza cad√°veres (decomposi√ß√£o)
                this.corpses.forEach(corpse => {
                    corpse.decay += this.globalDecay * deltaTime * 10;
                });
                this.corpses = this.corpses.filter(c => c.decay < 100);

                // Spawn de novos cad√°veres
                if (Math.random() < 0.001) this.spawnCorpse();

                // Movimento do jogador
                if (!this.player.echoMode) {
                    const speed = this.player.currentBody ? this.player.currentBody.stats.speed * 2 : 1;
                    if (this.keys['w']) this.player.y -= speed;
                    if (this.keys['s']) this.player.y += speed;
                    if (this.keys['a']) this.player.x -= speed;
                    if (this.keys['d']) this.player.x += speed;
                }

                // Atualiza c√¢mera (parallax)
                this.camera.x += (this.player.x - this.camera.x) * 0.1;
                this.camera.y += (this.player.y - this.camera.y) * 0.1;

                // Atualiza UI periodicamente
                if (Math.random() < 0.05) this.updateUI();
            }

            render() {
                // Limpa canvas
                this.ctx.fillStyle = '#0a0a0f';
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Renderiza biomas (camadas de parallax)
                this.biomes.forEach((biome, index) => {
                    const parallax = 0.5 + index * 0.1;
                    const bx = (biome.x - this.camera.x) * parallax + this.width / 2;
                    const by = (biome.y - this.camera.y) * parallax + this.height / 2;
                    
                    // Silhueta do bioma
                    this.ctx.save();
                    this.ctx.translate(bx, by);
                    this.ctx.fillStyle = biome.getBiomeColor();
                    this.ctx.globalAlpha = 0.3;
                    
                    const silhouette = biome.generateBiomeSilhouette();
                    this.ctx.beginPath();
                    silhouette.forEach((point, i) => {
                        if (i === 0) this.ctx.moveTo(point.x, point.y);
                        else this.ctx.lineTo(point.x, point.y);
                    });
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.restore();

                    // Part√≠culas
                    const particles = biome.generateParticles();
                    particles.forEach(p => {
                        this.ctx.fillStyle = biome.type === 'lung' ? 'rgba(57, 255, 20, 0.5)' : 'rgba(139, 38, 53, 0.3)';
                        this.ctx.fillRect(
                            (p.x - this.camera.x) * parallax + this.width / 2,
                            (p.y - this.camera.y) * parallax + this.height / 2,
                            2, 2
                        );
                    });
                });

                // Renderiza cad√°veres
                this.corpses.forEach(corpse => {
                    const cx = (corpse.x - this.camera.x) + this.width / 2;
                    const cy = (corpse.y - this.camera.y) + this.height / 2;
                    
                    this.ctx.font = '30px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.globalAlpha = 1 - (corpse.decay / 100);
                    this.ctx.fillText(this.getBodyEmoji(corpse.type), cx, cy);
                    this.ctx.globalAlpha = 1;
                    
                    // Indicador de decomposi√ß√£o
                    this.ctx.fillStyle = `rgb(${corpse.decay * 2.55}, ${255 - corpse.decay * 2.55}, 0)`;
                    this.ctx.fillRect(cx - 15, cy + 20, 30 * (1 - corpse.decay / 100), 3);
                });

                // Renderiza NPCs
                this.npcs.forEach(npc => {
                    if (!npc.dna.isAlive) return;
                    
                    const nx = (npc.x - this.camera.x) + this.width / 2;
                    const ny = (npc.y - this.camera.y) + this.height / 2;
                    
                    // Silhueta procedural baseada no DNA
                    this.ctx.save();
                    this.ctx.translate(nx, ny);
                    
                    const sil = npc.dna.silhouette;
                    this.ctx.scale(sil.width, sil.height);
                    this.ctx.rotate(sil.hunch);
                    
                    this.ctx.fillStyle = `rgba(232, 220, 196, ${0.5 + sil.corruption})`;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 20, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Indicador de profiss√£o
                    this.ctx.fillStyle = '#ffd700';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(npc.dna.profession.split(' ')[0], 0, -30);
                    
                    this.ctx.restore();
                });

                // Renderiza jogador
                const px = this.width / 2;
                const py = this.height / 2;
                
                if (this.player.echoMode) {
                    // Visual de eco
                    this.ctx.save();
                    this.ctx.translate(px, py);
                    this.ctx.strokeStyle = '#9400d3';
                    this.ctx.lineWidth = 2;
                    this.ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.3;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 30 + Math.sin(Date.now() / 300) * 5, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.fillStyle = '#9400d3';
                    this.ctx.font = '20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('‚óà', 0, 5);
                    this.ctx.restore();
                } else {
                    // Corpo atual
                    this.ctx.font = '40px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(
                        this.getBodyEmoji(this.player.currentBody.type),
                        px, py + 10
                    );
                    
                    // Aura de corrup√ß√£o
                    if (this.player.corruption > 20) {
                        this.ctx.save();
                        this.ctx.translate(px, py);
                        this.ctx.strokeStyle = `rgba(148, 0, 211, ${this.player.corruption / 200})`;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, 40, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.restore();
                    }
                }

                // Renderiza mapa de mem√≥ria
                this.renderMap();
            }

            renderMap() {
                const mapCanvas = document.getElementById('mapCanvas');
                const ctx = mapCanvas.getContext('2d');
                
                ctx.fillStyle = '#0a0a0f';
                ctx.fillRect(0, 0, 300, 200);
                
                const scale = 0.05;
                const offsetX = 150;
                const offsetY = 100;
                
                // Biomas no mapa
                this.biomes.forEach(biome => {
                    ctx.fillStyle = biome.getBiomeColor();
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(
                        offsetX + biome.x * scale,
                        offsetY + biome.y * scale,
                        biome.width * scale,
                        biome.height * scale
                    );
                });
                
                // Jogador
                ctx.fillStyle = '#39ff14';
                ctx.globalAlpha = 1;
                ctx.beginPath();
                ctx.arc(
                    offsetX + this.player.x * scale,
                    offsetY + this.player.y * scale,
                    3, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Anota√ß√µes
                ctx.fillStyle = '#ffd700';
                this.player.mapAnnotations.forEach(note => {
                    ctx.fillRect(note.x - 2, note.y - 2, 4, 4);
                });
            }

            startGameLoop() {
                const loop = () => {
                    const now = Date.now();
                    const deltaTime = now - this.lastTime;
                    this.lastTime = now;

                    this.update(deltaTime);
                    this.render();

                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }

            respawn(method) {
                document.getElementById('death-screen').classList.remove('active');
                
                if (method === 'near' && this.player.seeds > 0) {
                    this.player.seeds--;
                    this.showNotification('Ressurrei√ß√£o', 'Voc√™ retornou perto do corpo morto.');
                } else if (method === 'random') {
                    const biome = this.biomes[Math.floor(Math.random() * this.biomes.length)];
                    this.player.x = biome.x + Math.random() * biome.width;
                    this.player.y = biome.y + Math.random() * biome.height;
                    this.showNotification('Eco Aleat√≥rio', 'Voc√™ emergiu em um novo bioma.');
                } else if (method === 'possess') {
                    this.player.maxSanity *= 0.5;
                    this.showNotification('Possess√£o For√ßada', 'Voc√™ tomou o corpo do inimigo, mas sua sanidade est√° quebrada.');
                }

                // Recupera um corpo b√°sico
                const newBody = new Body('human');
                this.player.bodies = [newBody];
                this.player.currentBody = newBody;
                this.player.health = 100;
            }
        }

        // Inicia o jogo quando a p√°gina carregar
        window.onload = () => {
            window.game = new Game();
        };
    </script>
</body>
</html>
