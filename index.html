<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECOS DO ABISMO - Possessão Procedural</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Space+Mono:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --void: #0a0a0f;
            --flesh: #8b2635;
            --flesh-light: #c93a4f;
            --neural: #4a90e2;
            --toxic: #39ff14;
            --bone: #e8dcc4;
            --shadow: #1a1a2e;
            --gold: #ffd700;
            --corruption: #9400d3;
        }

        body {
            background: var(--void);
            color: var(--bone);
            font-family: 'Space Mono', monospace;
            overflow: hidden;
            position: relative;
        }

        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .hud-panel {
            position: absolute;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid var(--flesh);
            padding: 15px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        #possession-bar {
            top: 20px;
            left: 20px;
            min-width: 300px;
            border-left: 4px solid var(--toxic);
        }

        #possession-bar h2 {
            font-family: 'Cinzel', serif;
            color: var(--toxic);
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .body-slot {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.2s;
        }

        .body-slot:hover {
            background: rgba(57, 255, 20, 0.1);
            border-color: var(--toxic);
        }

        .body-slot.active {
            background: rgba(57, 255, 20, 0.2);
            border-color: var(--toxic);
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.3);
        }

        .body-icon {
            width: 40px;
            height: 40px;
            background: var(--shadow);
            border: 2px solid var(--flesh);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .body-info {
            flex: 1;
        }

        .body-name {
            font-weight: bold;
            color: var(--bone);
            font-size: 12px;
        }

        .body-condition {
            font-size: 10px;
            color: var(--flesh-light);
            margin-top: 2px;
        }

        .health-bar {
            width: 100%;
            height: 4px;
            background: var(--shadow);
            margin-top: 5px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--flesh), var(--flesh-light));
            transition: width 0.3s;
        }

        #world-status {
            top: 20px;
            right: 20px;
            text-align: right;
            border-right: 4px solid var(--corruption);
        }

        .decay-timer {
            font-size: 24px;
            font-weight: bold;
            color: var(--corruption);
            font-family: 'Cinzel', serif;
            text-shadow: 0 0 20px var(--corruption);
        }

        .biome-indicator {
            margin-top: 10px;
            font-size: 11px;
            color: var(--neural);
        }

        #echo-mode {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(148, 0, 211, 0.2);
            border: 2px solid var(--corruption);
            padding: 40px;
            text-align: center;
            display: none;
            pointer-events: auto;
            backdrop-filter: blur(20px);
            z-index: 200;
        }

        #echo-mode.active {
            display: block;
            animation: echoPulse 2s infinite;
        }

        @keyframes echoPulse {
            0%, 100% { box-shadow: 0 0 50px var(--corruption); }
            50% { box-shadow: 0 0 100px var(--corruption), inset 0 0 50px rgba(148, 0, 211, 0.3); }
        }

        #echo-mode h1 {
            font-family: 'Cinzel', serif;
            font-size: 32px;
            color: var(--corruption);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        .corpse-target {
            display: inline-block;
            margin: 10px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--flesh);
            cursor: pointer;
            transition: all 0.3s;
            min-width: 150px;
        }

        .corpse-target:hover {
            transform: scale(1.1);
            border-color: var(--toxic);
            box-shadow: 0 0 30px var(--toxic);
        }

        #dialogue-box {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            background: rgba(10, 10, 15, 0.98);
            border: 2px solid var(--gold);
            padding: 30px;
            display: none;
            pointer-events: auto;
        }

        #dialogue-box.active {
            display: block;
            animation: dialogueSlide 0.5s ease;
        }

        @keyframes dialogueSlide {
            from { transform: translateX(-50%) translateY(100px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        .npc-name {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 18px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .npc-mood {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--toxic);
        }

        .npc-text {
            font-size: 14px;
            line-height: 1.8;
            color: var(--bone);
            margin-bottom: 20px;
        }

        .dialogue-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .dialogue-btn {
            background: transparent;
            border: 1px solid var(--flesh);
            color: var(--bone);
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-size: 12px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .dialogue-btn:hover {
            background: var(--flesh);
            color: var(--void);
            transform: translateX(5px);
        }

        .dialogue-btn::before {
            content: '>';
            position: absolute;
            left: -20px;
            transition: left 0.3s;
        }

        .dialogue-btn:hover::before {
            left: 5px;
        }

        #memory-map {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 200px;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid var(--neural);
            pointer-events: auto;
            cursor: crosshair;
        }

        #memory-map canvas {
            width: 100%;
            height: 100%;
        }

        .map-hint {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 9px;
            color: var(--neural);
            opacity: 0.7;
        }

        #corruption-meter {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 30px;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--corruption);
            display: flex;
            flex-direction: column-reverse;
        }

        .corruption-fill {
            background: linear-gradient(to top, var(--corruption), var(--flesh));
            transition: height 0.5s;
            position: relative;
        }

        .corruption-label {
            position: absolute;
            right: 40px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
            font-size: 10px;
            color: var(--corruption);
            white-space: nowrap;
            letter-spacing: 2px;
        }

        .notification {
            position: fixed;
            top: 100px;
            right: -400px;
            background: rgba(10, 10, 15, 0.98);
            border-left: 4px solid var(--toxic);
            padding: 20px;
            max-width: 350px;
            transition: right 0.5s ease;
            pointer-events: auto;
            z-index: 150;
        }

        .notification.show {
            right: 20px;
        }

        .notification-title {
            font-family: 'Cinzel', serif;
            color: var(--toxic);
            font-size: 14px;
            margin-bottom: 8px;
        }

        .notification-text {
            font-size: 11px;
            color: var(--bone);
            line-height: 1.6;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--void);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            font-family: 'Cinzel', serif;
            font-size: 48px;
            color: var(--flesh);
            animation: loadingPulse 2s infinite;
            margin-bottom: 30px;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 0.3; text-shadow: 0 0 20px var(--flesh); }
            50% { opacity: 1; text-shadow: 0 0 50px var(--flesh), 0 0 100px var(--flesh); }
        }

        .loading-bar {
            width: 400px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .loading-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--flesh), var(--toxic));
            animation: loading 3s ease forwards;
        }

        @keyframes loading {
            to { width: 100%; }
        }

        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.3);
            line-height: 1.8;
        }

        .controls-hint span {
            color: var(--toxic);
            margin-right: 10px;
        }

        #possession-vfx {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s;
            background: radial-gradient(circle at center, transparent 0%, var(--corruption) 50%, transparent 100%);
            mix-blend-mode: screen;
        }

        #possession-vfx.active {
            opacity: 0.3;
            animation: possessionRipple 1s ease;
        }

        @keyframes possessionRipple {
            0% { transform: scale(0); opacity: 0; }
            50% { opacity: 0.5; }
            100% { transform: scale(3); opacity: 0; }
        }

        .trait-badge {
            display: inline-block;
            padding: 2px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 9px;
            margin: 2px;
            border-radius: 3px;
        }

        .trait-paranoid { border-color: var(--flesh); color: var(--flesh-light); }
        .trait-generous { border-color: var(--toxic); color: var(--toxic); }
        .trait-trauma { border-color: var(--corruption); color: var(--corruption); }

        #death-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
            pointer-events: auto;
        }

        #death-screen.active {
            display: flex;
        }

        .death-title {
            font-family: 'Cinzel', serif;
            font-size: 64px;
            color: var(--flesh);
            margin-bottom: 20px;
            animation: deathShake 0.5s infinite;
        }

        @keyframes deathShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .death-subtitle {
            font-size: 16px;
            color: var(--bone);
            margin-bottom: 40px;
            opacity: 0.7;
        }

        .echo-option {
            background: rgba(148, 0, 211, 0.2);
            border: 1px solid var(--corruption);
            padding: 20px 40px;
            margin: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .echo-option:hover {
            background: rgba(148, 0, 211, 0.4);
            transform: scale(1.05);
            box-shadow: 0 0 40px var(--corruption);
        }

        .echo-option h3 {
            color: var(--corruption);
            font-family: 'Cinzel', serif;
            margin-bottom: 10px;
        }

        .echo-option p {
            font-size: 11px;
            color: var(--bone);
            opacity: 0.8;
        }

        #audio-controls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid var(--neural);
            padding: 10px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 300;
        }

        .audio-btn {
            background: transparent;
            border: 1px solid var(--neural);
            color: var(--neural);
            padding: 5px 15px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s;
        }

        .audio-btn:hover {
            background: var(--neural);
            color: var(--void);
        }

        .audio-visualizer {
            width: 100px;
            height: 20px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
        }

        .audio-bar {
            flex: 1;
            background: var(--neural);
            transition: height 0.1s;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="loading-text">ECOS DO ABISMO</div>
        <div class="loading-bar">
            <div class="loading-progress"></div>
        </div>
        <div style="margin-top: 20px; font-size: 12px; color: var(--flesh-light);">
            Gerando DNA de 200+ NPCs... Criando biomas orgânicos...
        </div>
    </div>

    <div id="audio-controls" style="display: none;">
        <span style="font-size: 10px; color: var(--neural);">♫ SOM PROCEDURAL</span>
        <button class="audio-btn" onclick="audioManager.toggle()">ATIVAR/DESATIVAR</button>
        <div class="audio-visualizer" id="visualizer">
            <div class="audio-bar" style="height: 10%"></div>
            <div class="audio-bar" style="height: 30%"></div>
            <div class="audio-bar" style="height: 50%"></div>
            <div class="audio-bar" style="height: 70%"></div>
            <div class="audio-bar" style="height: 40%"></div>
        </div>
        <span id="current-biome-sound" style="font-size: 9px; color: var(--bone);">Bioma: Coração</span>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="possession-vfx"></div>

    <div id="ui-layer">
        <div id="possession-bar" class="hud-panel">
            <h2>◈ Corpos Possuídos</h2>
            <div id="body-list"></div>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="font-size: 10px; color: var(--toxic); margin-bottom: 5px;">CAMINHO ATUAL</div>
                <div id="current-path" style="font-size: 12px; font-weight: bold;">Eco Errante</div>
                <div id="path-progress" style="font-size: 10px; color: var(--bone); margin-top: 5px;">0/100 corpos consumidos</div>
            </div>
        </div>

        <div id="world-status" class="hud-panel">
            <div style="font-size: 10px; color: var(--corruption); margin-bottom: 5px;">DECADÊNCIA DO DEUS</div>
            <div class="decay-timer" id="decay-timer">71:59:59</div>
            <div class="biome-indicator" id="biome-indicator">
                ◈ Bioma: Cordão Umbilical<br>
                ◈ Temperatura: 37°C<br>
                ◈ Toxicidade: Baixa
            </div>
            <div style="margin-top: 15px; font-size: 10px; color: var(--gold);">
                ◈ Sementes: <span id="seeds-count">0</span><br>
                ◈ Memórias Vendidas: <span id="memories-count">0</span>
            </div>
        </div>

        <div id="corruption-meter">
            <div class="corruption-label">CORRUPÇÃO</div>
            <div class="corruption-fill" id="corruption-fill" style="height: 5%;"></div>
        </div>

        <div id="memory-map">
            <canvas id="mapCanvas"></canvas>
            <div class="map-hint">Clique para anotar • Scroll para zoom</div>
        </div>

        <div class="controls-hint">
            <span>[WASD]</span> Mover<br>
            <span>[E]</span> Interagir<br>
            <span>[ESPAÇO]</span> Modo Eco (possessão)<br>
            <span>[Q]</span> Trocar corpo<br>
            <span>[M]</span> Mapa de memória<br>
            <span>[TAB]</span> Inventário
        </div>
    </div>

    <div id="echo-mode">
        <h1>◈ MODO ECO ◈</h1>
        <p style="margin-bottom: 30px; opacity: 0.8;">Você está fora do corpo. Escolha um cadáver para possuir:</p>
        <div id="corpse-list"></div>
        <p style="margin-top: 30px; font-size: 11px; color: var(--corruption);">
            Cada possessão consome 5% de sanidade máxima permanente
        </p>
    </div>

    <div id="dialogue-box">
        <div class="npc-name">
            <div class="npc-mood" id="npc-mood"></div>
            <span id="npc-name">Nome do NPC</span>
            <div style="margin-left: auto; font-size: 10px; color: var(--flesh-light);" id="npc-traits"></div>
        </div>
        <div class="npc-text" id="npc-text">Texto do NPC aqui...</div>
        <div class="dialogue-options" id="dialogue-options"></div>
    </div>

    <div id="death-screen">
        <div class="death-title">◈ CORPO DESTRUÍDO ◈</div>
        <div class="death-subtitle">Sua consciência flutua no vazio entre os mundos</div>
        <div style="display: flex; gap: 20px;">
            <div class="echo-option" onclick="game.respawn('near')">
                <h3>ECO PROXIMAL</h3>
                <p>Reapareça perto do corpo morto<br>Custo: 1 Semente</p>
            </div>
            <div class="echo-option" onclick="game.respawn('random')">
                <h3>ECO ALEATÓRIO</h3>
                <p>Reapareça em bioma aleatório<br>Custo: 30% das memórias</p>
            </div>
            <div class="echo-option" onclick="game.respawn('possess')">
                <h3>POSSESSÃO FORÇADA</h3>
                <p>Controle o inimigo que te matou<br>Custo: 50% de sanidade máxima</p>
            </div>
        </div>
    </div>

    <script>
        // SISTEMA DE ÁUDIO PROCEDURAL
        class ProceduralAudio {
            constructor() {
                this.audioContext = null;
                this.isPlaying = false;
                this.currentBiome = 'heart';
                this.oscillators = [];
                this.gainNodes = [];
                this.analyser = null;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 32;
                this.initialized = true;
            }

            // Gera som baseado no bioma e nível de decadência
            generateBiomeSound(biomeType, decayLevel) {
                if (!this.initialized || !this.isPlaying) return;
                
                // Para sons anteriores
                this.stopAll();
                
                const now = this.audioContext.currentTime;
                const decayFactor = decayLevel / 100; // 0 a 1
                
                // Configurações de som por bioma
                const biomeSounds = {
                    heart: {
                        baseFreq: 60, // Batimento cardíaco lento
                        harmonics: [1, 1.5, 2],
                        waveform: 'sawtooth',
                        rhythm: 1.2, // BPM lento
                        filter: 200,
                        resonance: 5
                    },
                    lung: {
                        baseFreq: 80,
                        harmonics: [1, 2.3, 3.7],
                        waveform: 'sine',
                        rhythm: 0.8, // Respiração
                        filter: 400,
                        resonance: 3
                    },
                    brain: {
                        baseFreq: 200,
                        harmonics: [1, 1.25, 1.5, 2],
                        waveform: 'square',
                        rhythm: 0.3, // Rápido, neural
                        filter: 800,
                        resonance: 8
                    },
                    liver: {
                        baseFreq: 40,
                        harmonics: [1, 3, 5],
                        waveform: 'triangle',
                        rhythm: 2.0, // Lento, pesado
                        filter: 150,
                        resonance: 2
                    },
                    stomach: {
                        baseFreq: 30,
                        harmonics: [1, 1.8, 2.5],
                        waveform: 'sawtooth',
                        rhythm: 1.5,
                        filter: 100,
                        resonance: 4
                    }
                };
                
                const sound = biomeSounds[biomeType] || biomeSounds.heart;
                
                // Cria osciladores para cada harmônico
                sound.harmonics.forEach((harmonic, index) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    osc.type = sound.waveform;
                    // Frequência modulada pela decadência (mais caótico quando apodrece)
                    const freqVariation = (Math.random() - 0.5) * decayFactor * 50;
                    osc.frequency.value = sound.baseFreq * harmonic + freqVariation;
                    
                    // Filtro que muda com a decadência
                    filter.type = 'lowpass';
                    filter.frequency.value = sound.filter * (1 - decayFactor * 0.5);
                    filter.Q.value = sound.resonance * (1 + decayFactor);
                    
                    // Ganho modulado por LFO para criar ritmo
                    const lfo = this.audioContext.createOscillator();
                    lfo.type = 'sine';
                    lfo.frequency.value = sound.rhythm;
                    
                    const lfoGain = this.audioContext.createGain();
                    lfoGain.gain.value = 0.3 + (decayFactor * 0.4); // Mais instável quando apodrece
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(gain.gain);
                    
                    // Volume base
                    gain.gain.value = 0.1 / sound.harmonics.length;
                    
                    // Conecta: osc -> filter -> gain -> analyser -> destino
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);
                    
                    osc.start(now);
                    lfo.start(now);
                    
                    // Adiciona à lista para poder parar depois
                    this.oscillators.push(osc, lfo);
                    this.gainNodes.push(gain, lfoGain);
                });
                
                // Adiciona ruído baseado na decadência (mais ruído = mais podre)
                if (decayFactor > 0.3) {
                    const bufferSize = this.audioContext.sampleRate * 2;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * decayFactor * 0.3;
                    }
                    
                    const noise = this.audioContext.createBufferSource();
                    noise.buffer = buffer;
                    noise.loop = true;
                    
                    const noiseGain = this.audioContext.createGain();
                    noiseGain.gain.value = decayFactor * 0.1;
                    
                    noise.connect(noiseGain);
                    noiseGain.connect(this.analyser);
                    
                    noise.start(now);
                    this.oscillators.push(noise);
                    this.gainNodes.push(noiseGain);
                }
                
                this.currentBiome = biomeType;
                this.updateVisualizer();
            }

            stopAll() {
                this.oscillators.forEach(osc => {
                    try { osc.stop(); } catch(e) {}
                });
                this.oscillators = [];
                this.gainNodes = [];
            }

            toggle() {
                if (!this.initialized) this.init();
                
                this.isPlaying = !this.isPlaying;
                if (this.isPlaying) {
                    this.audioContext.resume();
                    if (game) this.generateBiomeSound(game.currentBiomeType || 'heart', 0);
                } else {
                    this.stopAll();
                }
            }

            updateVisualizer() {
                if (!this.isPlaying) return;
                
                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.analyser.getByteFrequencyData(dataArray);
                
                const bars = document.querySelectorAll('.audio-bar');
                bars.forEach((bar, index) => {
                    const value = dataArray[index] || 0;
                    const height = Math.max(10, (value / 255) * 100);
                    bar.style.height = height + '%';
                });
                
                requestAnimationFrame(() => this.updateVisualizer());
            }

            updateBiome(biomeType, decayLevel) {
                if (this.currentBiome !== biomeType && this.isPlaying) {
                    this.generateBiomeSound(biomeType, decayLevel);
                    document.getElementById('current-biome-sound').textContent = `Bioma: ${biomeType.charAt(0).toUpperCase() + biomeType.slice(1)}`;
                }
            }
        }

        const audioManager = new ProceduralAudio();

        // SISTEMA DE DNA PROCEDURAL PARA NPCs
        class DNA {
            constructor(seed = Math.random()) {
                this.seed = seed;
                this.rng = new RNG(seed);
                this.generate();
            }

            generate() {
                this.traits = {
                    paranoia: this.rng.next(0, 100),
                    altruism: this.rng.next(0, 100),
                    aggression: this.rng.next(0, 100),
                    curiosity: this.rng.next(0, 100),
                    loyalty: this.rng.next(0, 100),
                    trauma: this.rng.next(0, 100)
                };

                this.profession = this.selectProfession();
                this.name = this.generateName();
                this.lifeStory = this.generateLifeStory();
                this.playerMemories = [];
                this.age = this.rng.next(18, 70);
                this.maxAge = this.age + this.rng.next(5, 30);
                this.isAlive = true;
                this.silhouette = this.generateSilhouette();
            }

            selectProfession() {
                const professions = [
                    { name: 'Necromante de Lágrimas', req: t => t.trauma > 60 && t.curiosity > 50 },
                    { name: 'Ferreira de Ossos', req: t => t.aggression > 60 && t.paranoia < 40 },
                    { name: 'Mercador de Memórias', req: t => t.altruism < 30 && t.curiosity > 70 },
                    { name: 'Herege do Sangue', req: t => t.trauma > 70 && t.loyalty < 30 },
                    { name: 'Jardineiro de Fungos', req: t => t.altruism > 60 && t.aggression < 40 },
                    { name: 'Caçador de Ecos', req: t => t.aggression > 70 && t.paranoia > 50 },
                    { name: 'Sacerdote Podre', req: t => t.loyalty > 70 && t.trauma > 40 },
                    { name: 'Alquimista de Carne', req: t => t.curiosity > 80 && t.altruism < 50 },
                    { name: 'Pescador de Almas', req: t => t.trauma > 50 && t.aggression < 50 },
                    { name: 'Escriba de Cicatrizes', req: t => t.curiosity > 60 && t.paranoia > 40 }
                ];

                const valid = professions.filter(p => p.req(this.traits));
                return valid.length > 0 ? valid[this.rng.next(0, valid.length - 1)].name : professions[0].name;
            }

            generateName() {
                const prefixes = ['Kael', 'Mira', 'Zeth', 'Lys', 'Vorn', 'Iris', 'Obl', 'Xan', 'Yul', 'Kor'];
                const suffixes = ['-7', ' o Manchado', ' Vazio', ' de Cinzas', '-Null', ' ++', ' Ω', ' Ð', ' the Hollow', ' Prime'];
                const prefix = prefixes[this.rng.next(0, prefixes.length - 1)];
                const suffix = this.rng.next(0, 100) > 70 ? suffixes[this.rng.next(0, suffixes.length - 1)] : '';
                return prefix + suffix;
            }

            generateLifeStory() {
                const events = [
                    'testemunhou a queda do deus',
                    'perdeu a família para a podridão',
                    'foi traído por um eco',
                    'descobriu uma verdade proibida',
                    'foi ressuscitado 3 vezes',
                    'vendeu suas memórias de infância',
                    'possuiu um deus menor',
                    'sobreviveu ao colapso do fígado'
                ];
                return `Um ${this.profession.toLowerCase()} que ${events[this.rng.next(0, events.length - 1)]}.`;
            }

            generateSilhouette() {
                return {
                    height: this.rng.next(0.8, 1.4),
                    width: this.rng.next(0.6, 1.2),
                    hunch: this.rng.next(-0.3, 0.3),
                    limbs: this.rng.next(0.7, 1.3),
                    corruption: this.rng.next(0, this.traits.trauma / 100)
                };
            }

            interact(player, context) {
                let disposition = 50;
                this.playerMemories.forEach(mem => {
                    if (mem.type === 'betrayal') disposition -= 40;
                    if (mem.type === 'help') disposition += 30;
                    if (mem.type === 'trade_fair') disposition += 20;
                    if (mem.type === 'possessed_friend') disposition -= 60;
                });

                if (this.traits.paranoia > 70) disposition -= 20;
                if (this.traits.altruism > 70) disposition += 15;

                const recognized = this.playerMemories.some(m => m.playerId === player.id);

                return {
                    disposition: Math.max(0, Math.min(100, disposition)),
                    recognized,
                    dialogue: this.generateDialogue(disposition, recognized, context),
                    options: this.generateOptions(disposition, context)
                };
            }

            generateDialogue(disposition, recognized, context) {
                if (recognized && disposition < 30) {
                    return `Eu te reconheço, eco. Não importa que carne você veste agora. Você me traiu antes, e eu não esqueço.`;
                }
                if (recognized && disposition > 70) {
                    return `Ah, é você! Mesmo nesse novo vaso de carne, eu reconheço sua... essência. O que precisa, amigo?`;
                }
                if (this.traits.paranoia > 80) {
                    return `Não chegue perto. Eu sei o que você é. Eu sei o que TODOS são. Os ecos estão em toda parte.`;
                }
                if (context === 'first_meeting') {
                    return `Um novo eco flutuando pelo corpo do deus? Cuidado, carne estrangeira. Nem todos aqui apreciam... turistas.`;
                }
                return `Sou ${this.name}, ${this.profession.toLowerCase()}. O que você busca nas entranhas do cadáver divino?`;
            }

            generateOptions(disposition, context) {
                const options = [];
                if (disposition > 40) {
                    options.push({ text: 'Comércio', action: 'trade' });
                    options.push({ text: 'Informações', action: 'info' });
                }
                if (disposition > 70) {
                    options.push({ text: 'Seguir-me (Companion)', action: 'follow' });
                }
                if (this.profession.includes('Necromante') || this.profession.includes('Alquimista')) {
                    options.push({ text: 'Ressurreição', action: 'resurrect' });
                }
                options.push({ text: 'Ameaçar', action: 'threaten' });
                options.push({ text: 'Sair', action: 'leave' });
                return options;
            }

            addMemory(type, playerId, details) {
                this.playerMemories.push({ type, playerId, details, timestamp: Date.now() });
                const memoryLimit = 5 + Math.floor(this.traits.trauma / 20);
                if (this.playerMemories.length > memoryLimit) {
                    this.playerMemories.shift();
                }
            }

            update(deltaTime) {
                this.age += deltaTime / 3600;
                if (this.age >= this.maxAge && this.rng.next(0, 1000) < 1) {
                    this.isAlive = false;
                    return 'died_natural';
                }
                return 'alive';
            }
        }

        class RNG {
            constructor(seed) {
                this.seed = seed;
            }
            next(min = 0, max = 1) {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                const rnd = this.seed / 233280;
                return Math.floor(min + rnd * (max - min + 1));
            }
        }

        class Body {
            constructor(type, dna = null) {
                this.type = type;
                this.dna = dna;
                this.id = Math.random().toString(36).substr(2, 9);
                this.health = 100;
                this.maxHealth = 100;
                this.abilities = this.getAbilities();
                this.stats = this.getStats();
                this.age = 0;
                this.corruption = 0;
            }

            getAbilities() {
                const abilities = {
                    human: ['usar_itens', 'falar', 'comercio', 'correr'],
                    wolf: ['farejar', 'correr_rapido', 'morder', 'uivar'],
                    fungus: ['espores_venenosos', 'regeneracao', 'controle_micelio', 'crescer'],
                    fish: ['respirar_agua', 'nadar_rapido', 'bioluminescencia', 'eletrorecepção'],
                    bird: ['voar', 'visao_agucada', 'canto', 'mergulho'],
                    golem_flesh: ['forca_bruta', 'resistencia', 'auto_reparo', 'absorver_dano']
                };
                return abilities[this.type] || abilities.human;
            }

            getStats() {
                const stats = {
                    human: { speed: 1, damage: 10, defense: 10, special: 5 },
                    wolf: { speed: 2.5, damage: 15, defense: 5, special: 8 },
                    fungus: { speed: 0.3, damage: 20, defense: 20, special: 10 },
                    fish: { speed: 1.5, damage: 5, defense: 3, special: 7 },
                    bird: { speed: 3, damage: 8, defense: 2, special: 6 },
                    golem_flesh: { speed: 0.5, damage: 25, defense: 30, special: 3 }
                };
                return stats[this.type] || stats.human;
            }

            takeDamage(amount) {
                this.health -= amount * (1 - this.stats.defense / 100);
                return this.health <= 0;
            }

            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
            }
        }

        class Biome {
            constructor(name, type, x, y, width, height) {
                this.name = name;
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.decayLevel = 0;
                this.entities = [];
                this.connections = [];
                this.hazards = this.generateHazards();
                this.resources = this.generateResources();
            }

            generateHazards() {
                const hazards = {
                    heart: [{ type: 'lava_vein', damage: 20, x: 100, y: 100 }],
                    lung: [{ type: 'acid_pool', damage: 15, x: 200, y: 300 }],
                    brain: [{ type: 'neural_blast', damage: 25, x: 150, y: 150 }],
                    liver: [{ type: 'toxin_cloud', damage: 10, x: 300, y: 200 }],
                    stomach: [{ type: 'acid_wave', damage: 30, x: 400, y: 400 }]
                };
                return hazards[this.type] || [];
            }

            generateResources() {
                return Array(5).fill(null).map(() => ({
                    type: ['seed', 'memory_fragment', 'flesh_chunk', 'neural_crystal'][Math.floor(Math.random() * 4)],
                    x: this.x + Math.random() * this.width,
                    y: this.y + Math.random() * this.height,
                    collected: false
                }));
            }

            update(deltaTime, globalDecay) {
                this.decayLevel += globalDecay * deltaTime;
                if (this.decayLevel > 100) return 'collapsed';
                this.entities = this.entities.filter(e => e instanceof DNA ? e.isAlive : true);
                return 'active';
            }

            getVisualData() {
                return {
                    color: this.getBiomeColor(),
                    particles: this.generateParticles(),
                    silhouette: this.generateBiomeSilhouette()
                };
            }

            getBiomeColor() {
                const colors = {
                    heart: `hsl(0, ${70 - this.decayLevel}%, ${30 + this.decayLevel/3}%)`,
                    lung: `hsl(120, ${60 - this.decayLevel/2}%, ${25 + this.decayLevel/4}%)`,
                    brain: `hsl(220, ${80 - this.decayLevel}%, ${40 + this.decayLevel/5}%)`,
                    liver: `hsl(30, ${90 - this.decayLevel}%, ${20 + this.decayLevel/3}%)`,
                    stomach: `hsl(60, ${50 - this.decayLevel/2}%, ${15 + this.decayLevel/2}%)`
                };
                return colors[this.type] || '#333';
            }

            generateParticles() {
                const count = Math.floor(this.decayLevel / 10);
                return Array(count).fill(null).map(() => ({
                    x: this.x + Math.random() * this.width,
                    y: this.y + Math.random() * this.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    life: Math.random() * 100,
                    type: this.type === 'lung' ? 'spore' : 'dust'
                }));
            }

            generateBiomeSilhouette() {
                const points = [];
                const segments = 20;
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const radius = 100 + Math.sin(angle * 3) * 30 + Math.random() * 20;
                    points.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
                }
                return points;
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;

                this.camera = { x: 0, y: 0, zoom: 1, rotation: 0 };
                this.player = {
                    id: 'player_' + Math.random().toString(36).substr(2, 9),
                    x: 0,
                    y: 0,
                    currentBody: null,
                    bodies: [],
                    echoMode: false,
                    sanity: 100,
                    maxSanity: 100,
                    seeds: 0,
                    memoriesSold: 0,
                    corruption: 5,
                    path: 'Eco Errante',
                    pathProgress: 0,
                    mapAnnotations: []
                };

                this.npcs = [];
                this.biomes = [];
                this.corpses = [];
                this.particles = [];
                this.globalDecay = 0.001;
                this.startTime = Date.now();
                this.lastTime = Date.now();
                this.currentBiomeType = 'heart';

                this.keys = {};
                this.mouse = { x: 0, y: 0, clicked: false };

                this.init();
            }

            async init() {
                this.generateWorld();
                this.setupEventListeners();
                
                setTimeout(() => {
                    document.getElementById('loading-screen').classList.add('hidden');
                    document.getElementById('audio-controls').style.display = 'flex';
                    this.showNotification('Bem-vindo ao Cadáver', 'Você acordou nas entranhas de um deus morto. Encontre um corpo antes que seu eco se dissipe.');
                    this.startGameLoop();
                }, 3500);
            }

            generateWorld() {
                const organLayout = [
                    { name: 'Coração Ardente', type: 'heart', x: 0, y: 0, w: 800, h: 600 },
                    { name: 'Pulmão do Pântano', type: 'lung', x: -1000, y: -500, w: 900, h: 700 },
                    { name: 'Corteza Neural', type: 'brain', x: 1000, y: -800, w: 1000, h: 800 },
                    { name: 'Fígado Tóxico', type: 'liver', x: -800, y: 800, w: 700, h: 600 },
                    { name: 'Estômago Ácido', type: 'stomach', x: 1200, y: 600, w: 800, h: 700 }
                ];

                organLayout.forEach(organ => {
                    this.biomes.push(new Biome(organ.name, organ.type, organ.x, organ.y, organ.w, organ.h));
                });

                for (let i = 0; i < 200; i++) {
                    const biome = this.biomes[Math.floor(Math.random() * this.biomes.length)];
                    const dna = new DNA(Math.random());
                    const npc = {
                        dna: dna,
                        x: biome.x + Math.random() * biome.width,
                        y: biome.y + Math.random() * biome.height,
                        biome: biome,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        state: 'idle',
                        target: null
                    };
                    this.npcs.push(npc);
                    biome.entities.push(dna);
                }

                const startBiome = this.biomes[0];
                this.player.x = startBiome.x + startBiome.width / 2;
                this.player.y = startBiome.y + startBiome.height / 2;
                
                const initialBody = new Body('human');
                this.player.currentBody = initialBody;
                this.player.bodies.push(initialBody);

                for (let i = 0; i < 10; i++) {
                    this.spawnCorpse();
                }
            }

            spawnCorpse() {
                const biome = this.biomes[Math.floor(Math.random() * this.biomes.length)];
                const types = ['human', 'wolf', 'fungus', 'fish', 'bird', 'golem_flesh'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                this.corpses.push({
                    type: type,
                    x: biome.x + Math.random() * biome.width,
                    y: biome.y + Math.random() * biome.height,
                    biome: biome,
                    decay: 0,
                    body: new Body(type)
                });
            }

            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    this.handleInput(e.key.toLowerCase());
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });

                window.addEventListener('click', (e) => {
                    this.mouse.clicked = true;
                    setTimeout(() => this.mouse.clicked = false, 100);
                });

                window.addEventListener('resize', () => {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.canvas.width = this.width;
                    this.canvas.height = this.height;
                });

                const mapCanvas = document.getElementById('mapCanvas');
                mapCanvas.width = 300;
                mapCanvas.height = 200;
                
                mapCanvas.addEventListener('click', (e) => {
                    const rect = mapCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.addMapAnnotation(x, y);
                });
            }

            handleInput(key) {
                if (key === ' ') {
                    this.toggleEchoMode();
                } else if (key === 'q') {
                    this.cycleBody();
                } else if (key === 'e') {
                    this.interact();
                } else if (key === 'm') {
                    this.toggleMap();
                }
            }

            toggleEchoMode() {
                if (this.player.echoMode) {
                    this.player.echoMode = false;
                    document.getElementById('echo-mode').classList.remove('active');
                } else {
                    this.player.echoMode = true;
                    this.updateEchoUI();
                    document.getElementById('echo-mode').classList.add('active');
                    document.getElementById('possession-vfx').classList.add('active');
                    setTimeout(() => {
                        document.getElementById('possession-vfx').classList.remove('active');
                    }, 1000);
                }
            }

            updateEchoUI() {
                const corpseList = document.getElementById('corpse-list');
                corpseList.innerHTML = '';
                
                const nearby = this.corpses.filter(c => {
                    const dist = Math.hypot(c.x - this.player.x, c.y - this.player.y);
                    return dist < 300 && c.decay < 80;
                });

                if (nearby.length === 0) {
                    corpseList.innerHTML = '<p style="color: var(--flesh);">Nenhum cadáver viável próximo...</p>';
                    return;
                }

                nearby.forEach(corpse => {
                    const div = document.createElement('div');
                    div.className = 'corpse-target';
                    div.innerHTML = `
                        <div style="font-size: 24px; margin-bottom: 10px;">${this.getBodyEmoji(corpse.type)}</div>
                        <div style="font-weight: bold; color: var(--toxic);">${corpse.type.toUpperCase()}</div>
                        <div style="font-size: 10px; color: var(--bone); margin-top: 5px;">
                            Decomposição: ${Math.floor(corpse.decay)}%<br>
                            Habilidades: ${corpse.body.abilities.slice(0, 2).join(', ')}
                        </div>
                    `;
                    div.onclick = () => this.possess(corpse);
                    corpseList.appendChild(div);
                });
            }

            getBodyEmoji(type) {
                const emojis = { human: '👤', wolf: '🐺', fungus: '🍄', fish: '🐟', bird: '🦅', golem_flesh: '🧟' };
                return emojis[type] || '👤';
            }

            possess(corpse) {
                this.player.maxSanity -= 5;
                this.player.sanity = Math.min(this.player.sanity, this.player.maxSanity);
                this.player.bodies.push(corpse.body);
                this.player.currentBody = corpse.body;
                this.corpses = this.corpses.filter(c => c !== corpse);
                this.player.pathProgress++;
                this.updatePath();
                this.toggleEchoMode();
                this.showNotification('Possessão Completa', `Você agora habita um ${corpse.type}. Sanidade máxima reduzida para ${this.player.maxSanity}.`);
                this.updateUI();
            }

            updatePath() {
                const progress = this.player.pathProgress;
                if (progress > 100) this.player.path = 'Necromante de Carne';
                else if (progress > 50) this.player.path = 'Colecionador de Vessels';
                else if (progress > 20) this.player.path = 'Eco Faminto';
                
                const fungusTime = this.player.bodies.filter(b => b.type === 'fungus').length;
                if (fungusTime > 10) this.player.path = 'Sinfonia Fúngica';
                
                const kills = this.player.bodies.filter(b => b.type === 'human').length;
                if (kills > 30) this.player.path = 'Carnívoro de Consciências';
            }

            cycleBody() {
                if (this.player.bodies.length < 2) return;
                const currentIndex = this.player.bodies.indexOf(this.player.currentBody);
                const nextIndex = (currentIndex + 1) % this.player.bodies.length;
                this.player.currentBody = this.player.bodies[nextIndex];
                this.showNotification('Troca de Corpo', `Agora controlando: ${this.player.currentBody.type}`);
                this.updateUI();
            }

            interact() {
                const nearby = this.npcs.filter(n => {
                    const dist = Math.hypot(n.x - this.player.x, n.y - this.player.y);
                    return dist < 100;
                });

                if (nearby.length > 0) {
                    this.startDialogue(nearby[0]);
                }
            }

            startDialogue(npc) {
                const interaction = npc.dna.interact(this.player, 'first_meeting');
                const box = document.getElementById('dialogue-box');
                
                document.getElementById('npc-name').textContent = npc.dna.name;
                document.getElementById('npc-mood').style.background = 
                    interaction.disposition > 70 ? '#22c55e' : interaction.disposition > 40 ? '#eab308' : '#ef4444';
                
                const traitsDiv = document.getElementById('npc-traits');
                traitsDiv.innerHTML = '';
                Object.entries(npc.dna.traits).forEach(([trait, value]) => {
                    if (value > 70) {
                        const badge = document.createElement('span');
                        badge.className = `trait-badge trait-${trait}`;
                        badge.textContent = `${trait}: ${value}`;
                        traitsDiv.appendChild(badge);
                    }
                });

                document.getElementById('npc-text').textContent = interaction.dialogue;
                
                const optionsDiv = document.getElementById('dialogue-options');
                optionsDiv.innerHTML = '';
                interaction.options.forEach(opt => {
                    const btn = document.createElement('button');
                    btn.className = 'dialogue-btn';
                    btn.textContent = opt.text;
                    btn.onclick = () => this.handleDialogueOption(opt, npc);
                    optionsDiv.appendChild(btn);
                });

                box.classList.add('active');
            }

            handleDialogueOption(option, npc) {
                if (option.action === 'leave') {
                    document.getElementById('dialogue-box').classList.remove('active');
                } else if (option.action === 'trade') {
                    this.showNotification('Comércio', 'Sistema de troca em desenvolvimento...');
                } else if (option.action === 'threaten') {
                    npc.dna.addMemory('betrayal', this.player.id, 'Ameaçado durante diálogo');
                    this.showNotification('Ameaça', `${npc.dna.name} agora teme você.`);
                    document.getElementById('dialogue-box').classList.remove('active');
                }
            }

            addMapAnnotation(x, y) {
                this.player.mapAnnotations.push({ x, y, text: prompt('Anotação:') || '?' });
                this.showNotification('Mapa', 'Anotação adicionada ao mapa de memória.');
            }

            updateUI() {
                const bodyList = document.getElementById('body-list');
                bodyList.innerHTML = '';
                this.player.bodies.forEach((body, index) => {
                    const div = document.createElement('div');
                    div.className = `body-slot ${body === this.player.currentBody ? 'active' : ''}`;
                    div.innerHTML = `
                        <div class="body-icon">${this.getBodyEmoji(body.type)}</div>
                        <div class="body-info">
                            <div class="body-name">${body.type.toUpperCase()} #${index + 1}</div>
                            <div class="body-condition">Saúde: ${Math.floor(body.health)}% | Corrupção: ${Math.floor(body.corruption)}%</div>
                            <div class="health-bar">
                                <div class="health-fill" style="width: ${body.health}%"></div>
                            </div>
                        </div>
                    `;
                    bodyList.appendChild(div);
                });

                document.getElementById('seeds-count').textContent = this.player.seeds;
                document.getElementById('memories-count').textContent = this.player.memoriesSold;
                document.getElementById('current-path').textContent = this.player.path;
                document.getElementById('path-progress').textContent = `${this.player.pathProgress} corpos consumidos`;
                document.getElementById('corruption-fill').style.height = `${this.player.corruption}%`;

                const elapsed = (Date.now() - this.startTime) / 1000;
                const remaining = Math.max(0, 72 * 3600 - elapsed);
                const hours = Math.floor(remaining / 3600);
                const minutes = Math.floor((remaining % 3600) / 60);
                const seconds = Math.floor(remaining % 60);
                document.getElementById('decay-timer').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            showNotification(title, text) {
                const notif = document.createElement('div');
                notif.className = 'notification';
                notif.innerHTML = `
                    <div class="notification-title">${title}</div>
                    <div class="notification-text">${text}</div>
                `;
                document.body.appendChild(notif);
                setTimeout(() => notif.classList.add('show'), 100);
                setTimeout(() => {
                    notif.classList.remove('show');
                    setTimeout(() => notif.remove(), 500);
                }, 5000);
            }

            update(deltaTime) {
                this.biomes.forEach(biome => {
                    const status = biome.update(deltaTime, this.globalDecay);
                    if (status === 'collapsed') {
                        this.showNotification('Colapso', `${biome.name} apodreceu completamente!`);
                    }
                });

                this.npcs.forEach(npc => {
                    if (Math.random() < 0.02) {
                        npc.vx = (Math.random() - 0.5) * 0.5;
                        npc.vy = (Math.random() - 0.5) * 0.5;
                    }
                    npc.x += npc.vx * deltaTime * 0.1;
                    npc.y += npc.vy * deltaTime * 0.1;

                    if (npc.x < npc.biome.x) npc.x = npc.biome.x;
                    if (npc.x > npc.biome.x + npc.biome.width) npc.x = npc.biome.x + npc.biome.width;
                    if (npc.y < npc.biome.y) npc.y = npc.biome.y;
                    if (npc.y > npc.biome.y + npc.biome.height) npc.y = npc.biome.y + npc.biome.height;

                    npc.dna.update(deltaTime);
                });

                this.corpses.forEach(corpse => {
                    corpse.decay += this.globalDecay * deltaTime * 10;
                });
                this.corpses = this.corpses.filter(c => c.decay < 100);

                if (Math.random() < 0.001) this.spawnCorpse();

                if (!this.player.echoMode) {
                    const speed = this.player.currentBody ? this.player.currentBody.stats.speed * 2 : 1;
                    if (this.keys['w']) this.player.y -= speed;
                    if (this.keys['s']) this.player.y += speed;
                    if (this.keys['a']) this.player.x -= speed;
                    if (this.keys['d']) this.player.x += speed;
                }

                this.camera.x += (this.player.x - this.camera.x) * 0.1;
                this.camera.y += (this.player.y - this.camera.y) * 0.1;

                // Atualiza bioma atual para áudio
                const currentBiome = this.getCurrentBiome();
                if (currentBiome) {
                    this.currentBiomeType = currentBiome.type;
                    audioManager.updateBiome(currentBiome.type, currentBiome.decayLevel);
                    
                    // Atualiza UI de bioma
                    document.getElementById('biome-indicator').innerHTML = `
                        ◈ Bioma: ${currentBiome.name}<br>
                        ◈ Decadência: ${Math.floor(currentBiome.decayLevel)}%<br>
                        ◈ Tipo: ${currentBiome.type}
                    `;
                }

                if (Math.random() < 0.05) this.updateUI();
            }

            getCurrentBiome() {
                return this.biomes.find(b => 
                    this.player.x >= b.x && this.player.x <= b.x + b.width &&
                    this.player.y >= b.y && this.player.y <= b.y + b.height
                );
            }

            render() {
                this.ctx.fillStyle = '#0a0a0f';
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.biomes.forEach((biome, index) => {
                    const parallax = 0.5 + index * 0.1;
                    const bx = (biome.x - this.camera.x) * parallax + this.width / 2;
                    const by = (biome.y - this.camera.y) * parallax + this.height / 2;
                    
                    this.ctx.save();
                    this.ctx.translate(bx, by);
                    this.ctx.fillStyle = biome.getBiomeColor();
                    this.ctx.globalAlpha = 0.3;
                    
                    const silhouette = biome.generateBiomeSilhouette();
                    this.ctx.beginPath();
                    silhouette.forEach((point, i) => {
                        if (i === 0) this.ctx.moveTo(point.x, point.y);
                        else this.ctx.lineTo(point.x, point.y);
                    });
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.restore();

                    const particles = biome.generateParticles();
                    particles.forEach(p => {
                        this.ctx.fillStyle = biome.type === 'lung' ? 'rgba(57, 255, 20, 0.5)' : 'rgba(139, 38, 53, 0.3)';
                        this.ctx.fillRect(
                            (p.x - this.camera.x) * parallax + this.width / 2,
                            (p.y - this.camera.y) * parallax + this.height / 2,
                            2, 2
                        );
                    });
                });

                this.corpses.forEach(corpse => {
                    const cx = (corpse.x - this.camera.x) + this.width / 2;
                    const cy = (corpse.y - this.camera.y) + this.height / 2;
                    
                    this.ctx.font = '30px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.globalAlpha = 1 - (corpse.decay / 100);
                    this.ctx.fillText(this.getBodyEmoji(corpse.type), cx, cy);
                    this.ctx.globalAlpha = 1;
                    
                    this.ctx.fillStyle = `rgb(${corpse.decay * 2.55}, ${255 - corpse.decay * 2.55}, 0)`;
                    this.ctx.fillRect(cx - 15, cy + 20, 30 * (1 - corpse.decay / 100), 3);
                });

                this.npcs.forEach(npc => {
                    if (!npc.dna.isAlive) return;
                    
                    const nx = (npc.x - this.camera.x) + this.width / 2;
                    const ny = (npc.y - this.camera.y) + this.height / 2;
                    
                    this.ctx.save();
                    this.ctx.translate(nx, ny);
                    
                    const sil = npc.dna.silhouette;
                    this.ctx.scale(sil.width, sil.height);
                    this.ctx.rotate(sil.hunch);
                    
                    this.ctx.fillStyle = `rgba(232, 220, 196, ${0.5 + sil.corruption})`;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 20, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#ffd700';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(npc.dna.profession.split(' ')[0], 0, -30);
                    
                    this.ctx.restore();
                });

                const px = this.width / 2;
                const py = this.height / 2;
                
                if (this.player.echoMode) {
                    this.ctx.save();
                    this.ctx.translate(px, py);
                    this.ctx.strokeStyle = '#9400d3';
                    this.ctx.lineWidth = 2;
                    this.ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.3;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 30 + Math.sin(Date.now() / 300) * 5, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.fillStyle = '#9400d3';
                    this.ctx.font = '20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('◈', 0, 5);
                    this.ctx.restore();
                } else {
                    this.ctx.font = '40px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(
                        this.getBodyEmoji(this.player.currentBody.type),
                        px, py + 10
                    );
                    
                    if (this.player.corruption > 20) {
                        this.ctx.save();
                        this.ctx.translate(px, py);
                        this.ctx.strokeStyle = `rgba(148, 0, 211, ${this.player.corruption / 200})`;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, 40, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.restore();
                    }
                }

                this.renderMap();
            }

            renderMap() {
                const mapCanvas = document.getElementById('mapCanvas');
                const ctx = mapCanvas.getContext('2d');
                
                ctx.fillStyle = '#0a0a0f';
                ctx.fillRect(0, 0, 300, 200);
                
                const scale = 0.05;
                const offsetX = 150;
                const offsetY = 100;
                
                this.biomes.forEach(biome => {
                    ctx.fillStyle = biome.getBiomeColor();
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(
                        offsetX + biome.x * scale,
                        offsetY + biome.y * scale,
                        biome.width * scale,
                        biome.height * scale
                    );
                });
                
                ctx.fillStyle = '#39ff14';
                ctx.globalAlpha = 1;
                ctx.beginPath();
                ctx.arc(
                    offsetX + this.player.x * scale,
                    offsetY + this.player.y * scale,
                    3, 0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.fillStyle = '#ffd700';
                this.player.mapAnnotations.forEach(note => {
                    ctx.fillRect(note.x - 2, note.y - 2, 4, 4);
                });
            }

            startGameLoop() {
                const loop = () => {
                    const now = Date.now();
                    const deltaTime = now - this.lastTime;
                    this.lastTime = now;

                    this.update(deltaTime);
                    this.render();

                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }

            respawn(method) {
                document.getElementById('death-screen').classList.remove('active');
                
                if (method === 'near' && this.player.seeds > 0) {
                    this.player.seeds--;
                    this.showNotification('Ressurreição', 'Você retornou perto do corpo morto.');
                } else if (method === 'random') {
                    const biome = this.biomes[Math.floor(Math.random() * this.biomes.length)];
                    this.player.x = biome.x + Math.random() * biome.width;
                    this.player.y = biome.y + Math.random() * biome.height;
                    this.showNotification('Eco Aleatório', 'Você emergiu em um novo bioma.');
                } else if (method === 'possess') {
                    this.player.maxSanity *= 0.5;
                    this.showNotification('Possessão Forçada', 'Você tomou o corpo do inimigo, mas sua sanidade está quebrada.');
                }

                const newBody = new Body('human');
                this.player.bodies = [newBody];
                this.player.currentBody = newBody;
                this.player.health = 100;
            }
        }

        window.onload = () => {
            window.game = new Game();
        };
    </script>
</body>
</html>
